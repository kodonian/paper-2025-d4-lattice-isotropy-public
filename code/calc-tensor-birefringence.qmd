---
title: Continuum Isotropy from the Spherical 5-Design Geometry of the 24-Cell-Lattice
abstract: |
    Numerical analysis accompanying the manuscript:

        "Continuum Isotropy from the Spherical 5-Design Geometry of the 24-Cell-Lattice"

    This code evaluates kinematic and elastic isotropy properties of
    regular four-dimensional lattices, with emphasis on the hypercubic
    lattice (Z^4) and the 24-cell lattice (D4).

    All computations are performed in Euclidean signature using
    nearest-neighbor central-force models. Results probe the infrared
    (continuum) behavior relevant for emergent Lorentz-invariant
    kinematics.
author: Christoph Kovacs
date: 2025-12-18
---

```{python}
"""
Figure 3: Transverse Shear Mode Degeneracy and Birefringence

This script evaluates the polarization anisotropy of transverse
(shear) modes of the lattice dynamical matrix.

For each propagation direction k̂, the transverse sector consists of
three shear eigenvalues ω_TT,i²(k).

Tensor birefringence is quantified by
    δ_T(k) = (max_i ω_TT,i² − min_i ω_TT,i²) / ⟨ω_TT²⟩
averaged over propagation directions.

Results demonstrate:
    • Z⁴ & A₄: Persistent transverse mode splitting (birefringence).
      This confirms that spherical 3-designs (Simplex) cannot support
      an isotropic spin-2 / tensor field.
    • D₄: Exact degeneracy of transverse modes (δ_T ~ 10^-16).
      This establishes the absence of vacuum birefringence as a
      unique feature of the 24-cell geometry.
"""
import numpy as np
import matplotlib.pyplot as plt
import itertools

# ============================================================
# Configuration
# ============================================================

plt.rcParams.update({
    "font.family": "sans-serif",
    "font.size": 13,
    "axes.labelsize": 14,
    "axes.titlesize": 16,
    "legend.fontsize": 11,
    "xtick.labelsize": 12,
    "ytick.labelsize": 12,
    "lines.linewidth": 2.5
})

# ============================================================
# Lattice definitions
# ============================================================

def normalize_neighbors(neigh):
    neigh = np.asarray(neigh, dtype=float)
    norms = np.linalg.norm(neigh, axis=1, keepdims=True) + 1e-30
    return neigh / norms

def neighbors_Z4():
    vecs = []
    for i in range(4):
        v = np.zeros(4); 
        v[i] = 1.0
        vecs.append(v); 
        vecs.append(-v)
    return np.array(vecs, dtype=float)

def neighbors_D4():
    """24-cell / D4 root system. Norm = 1."""
    vecs = []
    for i in range(4):
        for j in range(i+1, 4):
            for s1 in (+1, -1):
                for s2 in (+1, -1):
                    v = np.zeros(4)
                    v[i] = s1
                    v[j] = s2
                    vecs.append(v)
    return np.array(vecs, dtype=float)

def neighbors_A4():
    # 5D -> 4D Projection of Simplex
    base = [1, -1, 0, 0, 0]
    perms = set(itertools.permutations(base))
    vecs_5d = np.array(list(perms), dtype=float)
    basis = np.array([
        [1/np.sqrt(2), -1/np.sqrt(2), 0, 0, 0],
        [1/np.sqrt(6), 1/np.sqrt(6), -2/np.sqrt(6), 0, 0],
        [1/np.sqrt(12), 1/np.sqrt(12), 1/np.sqrt(12), -3/np.sqrt(12), 0],
        [1/np.sqrt(20), 1/np.sqrt(20), 1/np.sqrt(20), 1/np.sqrt(20), -4/np.sqrt(20)]
    ])
    return vecs_5d @ basis.T

# ============================================================
# Dynamical Matrix Analysis
# ============================================================

def dynamical_matrix(kvec, neighbors):
    phase = neighbors @ kvec
    
    # OLD (Unstable for small k):
    # w = 1.0 - np.cos(phase)
    
    # NEW (Numerically stable):
    w = 2.0 * np.sin(0.5 * phase)**2
    
    return np.einsum("n,na,nb->ab", w, neighbors, neighbors)

def get_transverse_splitting_full(M):
    """
    Computes splitting directly from the full 4x4 spectrum.
    Assumes Central Forces:
      - 1 Longitudinal Mode (Stiffest / Highest Eigenvalue)
      - 3 Transverse Modes (Lower Eigenvalues)
    """
    # Get all 4 eigenvalues in ascending order
    evals = np.linalg.eigvalsh(M)
    
    # The first 3 are the transverse modes (shear)
    # The last 1 is the longitudinal mode (pressure)
    lam_transverse = evals[0:3]
    
    # Metric: Relative Splitting of the transverse sector
    # (max - min) / mean
    meanT = np.mean(lam_transverse) + 1e-30
    delta = (np.max(lam_transverse) - np.min(lam_transverse)) / meanT
    return delta

# ============================================================
# Anisotropy Calculation Loop
# ============================================================

def compute_transverse_anisotropy(neighbors, k_vals, n_directions=100, seed=42):
    rng = np.random.default_rng(seed)
    
    # Generate Directions
    dirs = rng.normal(size=(n_directions, 4))
    dirs /= np.linalg.norm(dirs, axis=1, keepdims=True)
    
    delta_T = np.zeros_like(k_vals, dtype=float)

    for ik, k in enumerate(k_vals):
        vals_T = []
        for d in dirs:
            kvec = k * d
            M = dynamical_matrix(kvec, neighbors)
            
            # Use the direct eigenvalue method
            dt = get_transverse_splitting_full(M)
            vals_T.append(dt)
            
        delta_T[ik] = np.mean(vals_T)

    return delta_T

# ============================================================
# Main Execution
# ============================================================

# Log-space for wide range cover
k_vals = np.logspace(-8.2, 0.0, 160)

# Normalize Lattices
neigh_Z4 = normalize_neighbors(neighbors_Z4())
neigh_A4 = normalize_neighbors(neighbors_A4())
neigh_D4 = normalize_neighbors(neighbors_D4())

print("Calculating transverse anisotropy...")
deltaT_Z4 = compute_transverse_anisotropy(neigh_Z4, k_vals)
deltaT_A4 = compute_transverse_anisotropy(neigh_A4, k_vals)
deltaT_D4 = compute_transverse_anisotropy(neigh_D4, k_vals)

# ============================================================
# Plot
# ============================================================

fig, ax = plt.subplots(figsize=(7.5, 5.5))

# Z4 Data
ax.plot(k_vals, deltaT_Z4, label=r"$\mathbb{Z}^4$: Birefringent", 
          lw=2.5, color="#1f77b4")

# A4 Data
ax.plot(k_vals, deltaT_A4, label=r"$A_4$: Birefringent", 
          lw=2.5, color="#2ca02c")

# D4 Data
ax.plot(k_vals, deltaT_D4, label=r"$D_4$: Degenerate", 
          lw=2.5, color="#ff7f0e")

# Numerical Floor Reference
ax.axhline(1e-15, color="grey", ls=":", lw=1.5, label="Numerical precision")

# IR Window
k_min_IR = 0.08
k_max_IR = 0.6
ax.axvspan(k_min_IR, k_max_IR, color="grey", alpha=0.12, label="IR continuum regime")

# Styling
ax.set_yscale("log")
ax.set_xlabel(r"Wavenumber magnitude $k$")
ax.set_ylabel(r"Tensor birefringence $\delta_\mathrm{T}(k)$")
ax.set_title("Tensor Birefringence of Transverse Shear Modes")

ax.legend(frameon=False, loc="center right")
ax.grid(True, which="both", ls="-", lw=0.5, alpha=0.3)
ax.set_xlim(-1e-2, k_vals[-1])
ax.set_ylim(1e-16, 5.0)


plt.tight_layout()
plt.show()

# ============================================================
# Validation Report
# ============================================================

def validation_check(name, neigh):
    # Single check direction
    k_vec = 1e-5 * np.array([1., 0.5, 0.2, 0.1]) / np.linalg.norm([1., 0.5, 0.2, 0.1])
    M = dynamical_matrix(k_vec, neigh)
    evals = np.linalg.eigvalsh(M)
    lam_T = evals[0:3]
    split = (np.max(lam_T) - np.min(lam_T)) / np.mean(lam_T)
    
    print(f"{name:15s} | Splitting: {split:.4e} | {'ISOTROPIC' if split < 1e-10 else 'ANISOTROPIC'}")

print("\n" + "="*50)
print("VALIDATION CHECK (Low-k limit)")
print("="*50)
validation_check("Z4 (Hypercubic)", neigh_Z4)
validation_check("A4 (Simplex)", neigh_A4)
validation_check("D4 (24-Cell)", neigh_D4)
print("="*50)
```


<!-- ==================================================
VALIDATION CHECK (Low-k limit)
==================================================
Z4 (Hypercubic) | Splitting: 2.4000e+00 | ANISOTROPIC
A4 (Simplex)    | Splitting: 4.0521e-01 | ANISOTROPIC
D4 (24-Cell)    | Splitting: 2.1297e-12 | ANISOTROPIC
================================================== -->